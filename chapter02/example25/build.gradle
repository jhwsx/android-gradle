import java.time.format.ResolverStyle

// 2.5 闭包
task helloClosure {
    doLast {
        customEach {
            println it
        }

        eachMap { k, v ->
            println "$k => $v"
        }

    }
}

static def customEach(closure1) {
    for (int i in 1..10) {
        closure1(i)
    }
}
// 向闭包传递参数
static def eachMap(closure) {
    def map1 = ["name": "zhangsan", "age": 18]
    map1.each {
        closure(it.key, it.value)
    }
}

// 闭包委托
// Groovy 的闭包有 thisObject，owner，delegate 三个属性
// 当在闭包内调用方法时，由它们来决定使用哪个对象来处理。
// 默认情况下 delegate 和 owner 是相等的，但是 delegate 是可以被修改的。
// Gradle 的闭包的很多功能都是通过修改 delegate 来实现的。
task helloDelegate {
    doLast {
        new Delegate().test {
            // thisObject 是构建脚本的上下文，它和脚本中的this对象是相等的。
            println "this:${this.getClass()}"
            println "thisObject:${thisObject.getClass()}"
            println "owner:${owner.getClass()}"
            println "delegate:${delegate.getClass()}"
            method1()
            it.method1()
        }
    }
}

def method1() {
    println "Context this:${this.getClass()} in root"
    println "method1 in root"
}

class Delegate {
    def method1() {
        println "Context this:${this.getClass()} in root"
        println "method1 in Delegate"
    }

    def test(Closure<Delegate> closure) {
        closure(this)
    }
}

task configClosure {
    doLast {
        person {
            personName = "zhangsan"
            personAge = 18
            dumpPerson()
        }
    }
}

class Person {
    String personName
    int personAge

    def dumpPerson() {
        println "name is $personName, age is $personAge"
    }
}

static def person(Closure<Person> closure) {
    Person p = new Person()
    // 我们一般会指定 delegate 为当前的 it，这样在闭包内就可以对该 it 进行配置，或者调用其方法
    // 闭包可以设置 delegate 对象，设置 delegate 的意义就是将闭包和一个具体的对象关联起来。
    // 这样在闭包中就可以访问被代理对象的属性和方法了。
    closure.delegate = p
    // 如果闭包所在的类或闭包中和被代理的类中有相同名称的方法，到底要调用哪个方法，所以设置解析策略。
    // Closure.OWNER_FIRST 是默认策略。优先在 owner 寻找，owner没有再delegate
    // Closure.DELEGATE_FIRST：优先再 delegate 寻找，delegate没有再owner
    // Closure.OWNER_ONLY：只在owner中寻找
    // Closure.DELEGATE_ONLY：只在delegate中寻找
    // Closure.TO_SELF
    closure.setResolveStrategy(Closure.DELEGATE_FIRST) // 设置委托模式优先
    closure(p)
}
task testResolveStrategy {
    doLast {
        new Test().run(DELEGATE_FIRST, "DELEGATE_FIRST")
        new Test().run(OWNER_FIRST, "OWNER_FIRST")
        new Test().run(OWNER_ONLY, "OWNER_ONLY")
        new Test().run(DELEGATE_ONLY, "DELEGATE_ONLY")
//        new Test().run(TO_SELF, "TO_SELF")
    }
}

class Test {
    def x = 30
    def y = 40

    def run(int strategy, String strategyName) {
        def data = new TestB()
        def cl = { y = x + y } // 这是一个闭包对象
        cl.delegate = data // 把闭包对象和一个具体的对象（data）关联起来
        cl.resolveStrategy = strategy
        cl() // 执行闭包对象
        println strategyName
        println x
        println y
        println data
    }

    class TestB {
        def x = 1
        def y = 2

        @Override
        String toString() {
            return "TestB{x = " + x + ", y = " + y + "}"
        }
    }
}
// 不指定参数的闭包，它有一个隐含的参数 it
def greeting = { "Hello, $it!" }
// 没有参数的闭包
def noParamClosure = { -> true }
// 多个参数不带参数类型的闭包
def multiParamWithoutTypeClosure = { a, b -> a + b }
// 多个参数带类型参数的闭包
def multiParamWithTypeClosure = { int a, int b -> a + b }

task testClosure {
    doLast {
        // 闭包的两种调用方式
        // 1, 闭包对象(参数)
        println greeting("world")
        // 2, 闭包对象.call(参数)
        println greeting.call("gradle")
        // 如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。
        // noParamClosure.call("") // 报错
        noParamClosure.call() // OK
        println multiParamWithoutTypeClosure.call(1, 2)
        println multiParamWithoutTypeClosure.call("hello", 1)
        println multiParamWithTypeClosure.call(100, 200)
    }
}

// 理解闭包内this，owner，delegate对象
// 参考：https://mp.weixin.qq.com/s/MjrHHMzayEwEs6qX0sxb6g
// 在闭包内部，有三个内置对象this，owner，delegate，我们可以直接用this，owner，delegate调用，或者用 get 方法：
// getThisObject() 等同于 this
// getOwner() 等同于 owner
// getDelegate() 等同于 delegate
// this 对应于定义闭包的那个类，如果在内部类中定义，指向的是内部类
// owner 对应于定义闭包的那个类或者闭包，如果在闭包中定义，对应闭包，否则同this一致
// delegate 默认是和owner一致，或者自定义delegate指向
// this 永远是指定义该闭包的类，如果存在内部类，则是最内层的类，但this不是指当前闭包对象
// owner 永远是指定义该闭包的类或者闭包，顾名思义，闭包只能定义在类中或者闭包中
// delegate 默认是指 owner，可以自己设置。
task hiClosure {
    doLast {
        new OuterClass().callInnerMethod()
    }
}

class OuterClass {
    // 内部类
    class InnerClass {
        // outerClosure 是 InnerClass 的成员变量
        def outerClosure = {
            def innerClosure = {
            }
            printfMsg("innerClosure", innerClosure)
            println "-------------"
            printfMsg("outerClosure", outerClosure)
        }
        // printfMsg 是 InnerClass 的成员方法
        void printfMsg(String flag, Closure closure) {
            def thisObject = closure.getThisObject()
            def ownerObject = closure.getOwner()
            def delegate = closure.getDelegate()
            println "$flag this: ${thisObject.toString()}"
            println "$flag owner: ${ownerObject.toString()}"
            println "$flag delegate: ${delegate.toString()}"
        }
    }
    // callInnerMethod 是 OuterClass 的成员方法
    def callInnerMethod() {
        def innerClass = new InnerClass()
        innerClass.outerClosure.call() // 执行 outerClosure 这个闭包对象
        println "-------------"
        println "outerClosure toString ${innerClass.outerClosure.toString()}"
    }
}

/*
task hiClosure 打印结果：
innerClosure this: OuterClass$InnerClass@3e7371cd // 等于内部类 InnerClass 对象
innerClosure owner: OuterClass$InnerClass$_closure1@25d55df8 // 等于 outerClosure 对象
innerClosure delegate: OuterClass$InnerClass$_closure1@25d55df8 // 默认和 owner 一致的指向
-------------
outerClosure this: OuterClass$InnerClass@3e7371cd // 等于内部类 InnerClass 对象
outerClosure owner: OuterClass$InnerClass@3e7371cd // 等于内部类 InnerClass 对象
outerClosure delegate: OuterClass$InnerClass@3e7371cd // 默认和 owner 一致的指向
-------------
outerClosure toString OuterClass$InnerClass$_closure1@25d55df8
 */

task delegateDemo {
    doLast {
        mywith {
            name = "Birdy"
            age = 18
            p()
            fly()
        }
    }
}

static def mywith(Closure<Person> closure) {
    Bird b = new Bird()
    closure.delegate = b
    closure.setResolveStrategy(Closure.DELEGATE_ONLY)
    closure.call()
}

class Bird {
    String name;
    int age;

    void fly() {
        println "fly()"
    }

    void p() {
        println toString()
    }


    @Override
    String toString() {
        return "Bird{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
// 仿照Android DSL 定义闭包
task androidClosure {
    doLast {
        android1 {
            compileSdkVersion1  29
            buildToolsVersion1 '28.0.0'
            defaultConfig1 {
                minSdkVersion1  15
                targetSdkVersion1  29
                versionCode1 = 100
                versionName1 = '1.0.0'
            }
            output()
        }
    }
}

class Android1 {
    int compileSdkVersion1
    String buildToolsVersion1
    DefaultConfig1 defaultConfig1 = new DefaultConfig1()

    void compileSdkVersion1(int compileSdkVersion) {
        this.compileSdkVersion1 = compileSdkVersion
    }

    void buildToolsVersion1(String buildToolsVersion) {
        this.buildToolsVersion1 = buildToolsVersion
    }

    void defaultConfig1(Closure<DefaultConfig1> closure) {
        closure.delegate = defaultConfig1
        closure.setResolveStrategy(Closure.DELEGATE_ONLY)
        closure(defaultConfig1)
    }

    void output() {
        println toString()
    }
    @Override
    String toString() {
        return "Android1{" +
                "compileSdkVersion1=" + compileSdkVersion1 +
                ", buildToolsVersion1='" + buildToolsVersion1 + '\'' +
                ", defaultConfig1=" + defaultConfig1 +
                '}';
    }
}

static void android1(Closure<Android1> closure) {
    Android1 android = new Android1()
    closure.delegate = android
    closure.setResolveStrategy(Closure.DELEGATE_ONLY)
    closure(android)
}

class DefaultConfig1 {
    int minSdkVersion1
    int targetSdkVersion1
    int versionCode1
    String versionName1

    void minSdkVersion1(int minSdkVersion) {
        this.minSdkVersion1 = minSdkVersion
    }

    void targetSdkVersion1(int targetSdkVersion) {
        this.targetSdkVersion1 = targetSdkVersion
    }

    void versionCode1(int versionCode) {
        this.versionCode1 = versionCode
    }

    void versionName1(String versionName) {
        this.versionName1 = versionName
    }

    @Override
    String toString() {
        return "DefaultConfig1{" +
                "minSdkVersion1=" + minSdkVersion1 +
                ", targetSdkVersion1=" + targetSdkVersion1 +
                ", versionCode1=" + versionCode1+
                ", versionName1='" + versionName1 + '\'' +
                '}';
    }
}

