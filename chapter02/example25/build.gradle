import java.time.format.ResolverStyle

// 2.5 闭包
task helloClosure {
    doLast {
        customEach {
            println it
        }

        eachMap { k, v ->
            println "$k => $v"
        }

    }
}

static def customEach(closure1) {
    for (int i in 1..10) {
        closure1(i)
    }
}
// 向闭包传递参数
static def eachMap(closure) {
    def map1 = ["name": "zhangsan", "age": 18]
    map1.each {
        closure(it.key, it.value)
    }
}

// 闭包委托
// Groovy 的闭包有 thisObject，owner，delegate 三个属性
// 当在闭包内调用方法时，由它们来决定使用哪个对象来处理。
// 默认情况下 delegate 和 owner 是相等的，但是 delegate 是可以被修改的。
// Gradle 的闭包的很多功能都是通过修改 delegate 来实现的。
task helloDelegate {
    doLast {
        new Delegate().test {
            // thisObject 是构建脚本的上下文，它和脚本中的this对象是相等的。
            println "this:${this.getClass()}"
            println "thisObject:${thisObject.getClass()}"
            println "owner:${owner.getClass()}"
            println "delegate:${delegate.getClass()}"
            method1()
            it.method1()
        }
    }
}

def method1() {
    println "Context this:${this.getClass()} in root"
    println "method1 in root"
}

class Delegate {
    def method1() {
        println "Context this:${this.getClass()} in root"
        println "method1 in Delegate"
    }

    def test(Closure<Delegate> closure) {
        closure(this)
    }
}

task configClosure {
    doLast {
        person {
            personName = "zhangsan"
            personAge = 18
            dumpPerson()
        }
    }
}

class Person {
    String personName
    int personAge

    def dumpPerson() {
        println "name is $personName, age is $personAge"
    }
}

static def person(Closure<Person> closure) {
    Person p = new Person()
    // 我们一般会指定 delegate 为当前的 it，这样在闭包内就可以对该 it 进行配置，或者调用其方法
    // 闭包可以设置 delegate 对象，设置 delegate 的意义就是将闭包和一个具体的对象关联起来。
    closure.delegate = p
    // 如果闭包所在的类或闭包中和被代理的类中有相同名称的方法，到底要调用哪个方法，所以设置解析策略。
    // 设置委托模式优先
    // Closure.OWNER_FIRST 是默认策略。优先在 owner 寻找，owner没有再delegate
    // Closure.DELEGATE_FIRST：优先再 delegate 寻找，delegate没有再owner
    // Closure.OWNER_ONLY：只在owner中寻找
    // Closure.DELEGATE_ONLY：只在delegate中寻找
    // Closure.TO_SELF
    closure.setResolveStrategy(Closure.DELEGATE_FIRST)
    closure(p)
}
// 不指定参数的闭包，它有一个隐含的参数 it
def greeting = { "Hello, $it!" }
// 没有参数的闭包
def noParamClosure = { -> true }
// 多个参数不带参数类型的闭包
def multiParamWithoutTypeClosure = { a, b -> a + b }
// 多个参数带类型参数的闭包
def multiParamWithTypeClosure = { int a, int b -> a + b }

task testClosure {
    doLast {
        // 闭包的两种调用方式
        // 1, 闭包对象(参数)
        println greeting("world")
        // 2, 闭包对象.call(参数)
        println greeting.call("gradle")
        // 如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。
        // noParamClosure.call("") // 报错
        noParamClosure.call() // OK
        println multiParamWithoutTypeClosure.call(1, 2)
        println multiParamWithoutTypeClosure.call("hello", 1)
        println multiParamWithTypeClosure.call(100, 200)
    }
}

// 在闭包内部，有三个内置对象this，owner，delegate，我们可以直接用this，owner，delegate调用，或者用 get 方法：
// getThisObject() 等同于 this
// getOwner() 等同于 owner
// getDelegate() 等同于 delegate
// this 对应于定义闭包的那个类，如果在内部类中定义，指向的是内部类
// owner 对应于定义闭包的那个类或者闭包，如果在闭包中定义，对应闭包，否则同this一致
// delegate 默认是和owner一致，或者自定义delegate指向
// this 永远是指定义该闭包的类，如果存在内部类，则是最内层的类，但this不是指当前闭包对象
// owner 永远是指定义该闭包的类或者闭包，顾名思义，闭包只能定义在类中或者闭包中
// delegate 默认是指 owner，可以自己设置。
task hiClosure {
    doLast {
        new OuterClass().callInnerMethod()
    }
}

class OuterClass {
    class InnerClass {
        def outerClosure = {
            def innerClosure = {
            }
            printfMsg("innerClosure", innerClosure)
            println "-------------"
            printfMsg("outerClosure", outerClosure)
        }

        void printfMsg(String flag, Closure closure) {
            def thisObject = closure.getThisObject()
            def ownerObject = closure.getOwner()
            def delegate = closure.getDelegate()
            println "$flag this: ${thisObject.toString()}"
            println "$flag owner: ${ownerObject.toString()}"
            println "$flag delegate: ${delegate.toString()}"
        }
    }

    def callInnerMethod() {
        def innerClass = new InnerClass()
        innerClass.outerClosure.call()
        println "-------------"
        println "outerClosure toString ${innerClass.outerClosure.toString()}"
    }
}

/*
task hiClosure 打印结果：
innerClosure this: OuterClass$InnerClass@3e7371cd
innerClosure owner: OuterClass$InnerClass$_closure1@25d55df8
innerClosure delegate: OuterClass$InnerClass$_closure1@25d55df8
-------------
outerClosure this: OuterClass$InnerClass@3e7371cd
outerClosure owner: OuterClass$InnerClass@3e7371cd
outerClosure delegate: OuterClass$InnerClass@3e7371cd
-------------
outerClosure toString OuterClass$InnerClass$_closure1@25d55df8
 */

task delegateDemo {
    doLast {
        with {
            name = "Birdy"
            age = 18
            p()
            fly()
        }
    }
}

static def with(Closure<Person> closure) {
    Bird b = new Bird()
    closure.delegate = b
    closure.setResolveStrategy(Closure.DELEGATE_ONLY)
    closure.call()
}

class Bird {
    String name;
    int age;

    void fly() {
        println "fly()"
    }

    void p() {
        println toString()
    }


    @Override
    String toString() {
        return "Bird{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

task androidClosure {
    doLast {
        android {
            compileSdkVersion  29
            buildToolsVersion '28.0.0'
            defaultConfig {
                minSdkVersion  15
                targetSdkVersion  29
                versionCode = 100
                versionName = '1.0.0'
            }
            output()
        }
    }
}

class Android {
    int compileSdkVersion
    String buildToolsVersion
    DefaultConfig defaultConfig = new DefaultConfig()

    void compileSdkVersion(int compileSdkVersion) {
        this.compileSdkVersion = compileSdkVersion
    }

    void buildToolsVersion(String buildToolsVersion) {
        this.buildToolsVersion = buildToolsVersion
    }

    void defaultConfig(Closure<DefaultConfig> closure) {
        closure.delegate = defaultConfig
        closure.setResolveStrategy(Closure.DELEGATE_ONLY)
        closure(defaultConfig)
    }

    void output() {
        println toString()
    }
    @Override
    String toString() {
        return "Android{" +
                "compileSdkVersion=" + compileSdkVersion +
                ", buildToolsVersion='" + buildToolsVersion + '\'' +
                ", defaultConfig=" + defaultConfig +
                '}';
    }
}

static void android(Closure<Android> closure) {
    Android android = new Android()
    closure.delegate = android
    closure.setResolveStrategy(Closure.DELEGATE_ONLY)
    closure(android)
}

class DefaultConfig {
    int minSdkVersion
    int targetSdkVersion
    int versionCode
    String versionName

    void minSdkVersion(int minSdkVersion) {
        this.minSdkVersion = minSdkVersion
    }

    void targetSdkVersion(int targetSdkVersion) {
        this.targetSdkVersion = targetSdkVersion
    }

    void versionCode(int versionCode) {
        this.versionCode = versionCode
    }

    void versionName(String versionName) {
        this.versionName = versionName
    }

    @Override
    String toString() {
        return "DefaultConfig{" +
                "minSdkVersion=" + minSdkVersion +
                ", targetSdkVersion=" + targetSdkVersion +
                ", versionCode=" + versionCode +
                ", versionName='" + versionName + '\'' +
                '}';
    }
}

